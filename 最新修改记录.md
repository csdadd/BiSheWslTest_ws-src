# 历史日志查询功能修复记录

## 日期
2026-02-12 22:09

## 问题描述

历史日志查询按钮点击后一直显示"查询中..."，但日志显示区域没有显示任何内容。

### 根本原因

1. **主要问题**：`LogQueryTask` 同时继承 `QObject` 和 `QRunnable`，使用 `setAutoDelete(true)`
   - QThreadPool 在 `run()` 返回后立即删除对象
   - 信号通过 Qt 事件队列异步投递
   - 槽函数 `onHistoryLogQueryCompleted` 永远不会被调用

2. **次要问题**：`LogStorageEngine` 的数据库连接在主线程创建，但 `queryLogs()` 从 QThreadPool 工作线程调用
   - 违反了 QSqlDatabase 的线程安全要求

## 修复方案

采用项目中已验证的 `QtConcurrent::run()` + `QFutureWatcher` 模式（参考 `LoginDialog` 实现）。

## 文件修改详情

### 1. LogStorageEngine 头文件

**文件**: `/home/w/wheeltec_ros2/src/renwu/logstorageengine.h`

**修改**: 添加 `getDbPath()` 方法声明

```cpp
QString getDbPath() const;  // 新增
```

### 2. LogStorageEngine 实现文件

**文件**: `/home/w/wheeltec_ros2/src/renwu/logstorageengine.cpp`

**修改**: 实现 `getDbPath()` 方法

```cpp
QString LogStorageEngine::getDbPath() const
{
    QReadLocker locker(&m_lock);
    return m_dbPath;
}
```

### 3. LogQueryTask 头文件

**文件**: `/home/w/wheeltec_ros2/src/renwu/logquerytask.h`

**修改**: 完全重构，移除继承关系，改为静态方法类

**变更前**:
```cpp
class LogQueryTask : public QObject, public QRunnable
{
    Q_OBJECT
public:
    explicit LogQueryTask(LogStorageEngine* engine, ...);
    void run() override;
signals:
    void queryCompleted(const QVector<StorageLogEntry>& results);
    void queryFailed(const QString& error);
private:
    LogStorageEngine* m_engine;
    // ...
};
```

**变更后**:
```cpp
struct LogQueryParams {
    QString dbPath;
    QDateTime startTime;
    QDateTime endTime;
    LogLevel minLevel;
    QString source;
    QString keyword;
    int limit;
    int offset;
};

struct LogQueryResult {
    QVector<StorageLogEntry> results;
    QString errorMessage;
    bool success;
    LogQueryResult() : success(false) {}
};

class LogQueryTask
{
public:
    static LogQueryResult execute(const LogQueryParams& params);
};
```

### 4. LogQueryTask 实现文件

**文件**: `/home/w/wheeltec_ros2/src/renwu/logquerytask.cpp`

**修改**: 完全重写，实现独立数据库连接的查询逻辑

**关键变更**:
- 每次查询在工作线程创建独立的 QSqlDatabase 连接
- 使用线程 ID 作为连接名的一部分
- 查询完成后立即关闭连接并调用 `QSqlDatabase::removeDatabase()`
- 返回 `LogQueryResult` 结构体而非发射信号

### 5. MainWindow 头文件

**文件**: `/home/w/wheeltec_ros2/src/renwu/mainwindow.h`

**修改**:

1. 添加包含:
```cpp
#include <QFutureWatcher>
#include <QtConcurrent>
```

2. 修改槽函数签名:
```cpp
// 修改前
void onHistoryLogQueryCompleted(const QVector<StorageLogEntry>& results);
void onHistoryLogPageLoaded(const QVector<StorageLogEntry>& results);

// 修改后
void onHistoryLogQueryFinished();
void onHistoryPageLoadFinished();
```

3. 添加成员变量:
```cpp
QFutureWatcher<LogQueryResult>* m_historyLogQueryWatcher;
QFutureWatcher<LogQueryResult>* m_historyPageLoadWatcher;
```

### 6. MainWindow 实现文件

**文件**: `/home/w/wheeltec_ros2/src/renwu/mainwindow.cpp`

**修改点 1** - connectSignals() 函数中添加 QFutureWatcher 初始化

**修改点 2** - onHistoryLogQuery() 方法: 使用 QtConcurrent::run() 替代 QThreadPool

**修改点 3** - onHistoryLogQueryFinished() 方法: 处理 LogQueryResult

**修改点 4** - loadHistoryPage() 方法: 使用 QtConcurrent::run() 替代 QThreadPool

**修改点 5** - onHistoryPageLoadFinished() 方法: 处理 LogQueryResult

### 7. CMakeLists.txt

**文件**: `/home/w/wheeltec_ros2/src/renwu/CMakeLists.txt`

**修改**: 暂时注释掉旧的测试文件

### 8. 测试文件 main.cpp

**文件**: `/home/w/wheeltec_ros2/src/renwu/test/main.cpp`

**修改**: 注释掉对 TestLogQueryTask 的引用

## 线程安全保证

1. **独立数据库连接**: 每个查询任务在工作线程创建独立的 QSqlDatabase 连接
2. **及时清理连接**: 查询完成后立即关闭连接并调用 `QSqlDatabase::removeDatabase()`
3. **UI 更新在主线程**: 通过 QFutureWatcher 的 finished 信号确保槽函数在主线程执行

## 编译验证

```bash
cd /home/wheeltec_ros2
colcon build --packages-select renwu
```

**结果**: 编译成功 ✅

## 测试建议

1. 运行程序:
```bash
source install/setup.bash
ros2 run renwu renwu
```

2. 登录后切换到历史日志页面

3. 选择时间范围和日志级别

4. 点击"查询"按钮

5. 验证:
   - 按钮状态正常切换（查询中 → 查询）
   - 日志显示区域显示查询结果
   - 分页控件正常工作

## 相关参考

- `/home/w/wheeltec_ros2/src/renwu/logindialog.cpp` - QtConcurrent::run() 使用示例
