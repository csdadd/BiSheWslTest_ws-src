# 修改记录

## 问题描述
修改日志写入数据库的策略：
1. 除里程计(ODOMETRY)日志以外的其他级别日志，将批量写入改为定时写入（2秒间隔）
2. HIGHFREQ 日志的批量写入阈值从 50 条改为 4 条

## 修改文件列表
- `renwu/logthread.h`: 添加定时写入相关成员变量
- `renwu/logthread.cpp`: 实现定时写入逻辑，修改 HIGHFREQ 批量阈值

## 修改详情

### renwu/logthread.h
**修改位置**: 行70-78

```diff
 private:
     QFile m_logFile;
     QTextStream m_logStream;
     ThreadSafeQueue<LogEntry> m_logQueue;
 
     QString m_logFilePath;
     QString m_logDirectory;
     qint64 m_maxFileSize;
     int m_maxFileCount;
     QMutex m_fileMutex;
     LogStorageEngine* m_storageEngine;
     QString m_currentLogDate;
     int m_processCount = 0;
 
+    QVector<StorageLogEntry> m_pendingBatchEntries;
+    QDateTime m_lastBatchWriteTime;
 
     static constexpr qint64 DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024;
     static constexpr int DEFAULT_MAX_FILE_COUNT = 5;
+    static constexpr int BATCH_WRITE_INTERVAL_MS = 2000;
 };
```

### renwu/logthread.cpp
**修改位置1**: 行81-91 (cleanup函数)

```diff
 void LogThread::cleanup()
 {
     processLogQueue();
 
+    if (!m_pendingBatchEntries.isEmpty() && m_storageEngine && m_storageEngine->isInitialized()) {
+        if (!m_storageEngine->insertLogs(m_pendingBatchEntries)) {
+            qWarning() << "[LogThread] Failed to insert remaining logs to database during cleanup";
+        }
+        m_pendingBatchEntries.clear();
+    }
+
     QMutexLocker locker(&m_fileMutex);
```

**修改位置2**: 行103-181 (processLogQueue函数)

```diff
 void LogThread::processLogQueue()
 {
-    QVector<StorageLogEntry> batchEntries;
     QVector<StorageLogEntry> highFreqBatchEntries;
     QVector<StorageLogEntry> odometryBatchEntries;
     LogEntry entry;
 
     while (m_logQueue.tryDequeue(entry, 0)) {
         if (entry.level == LogLevel::HIGHFREQ) {
             // ...
-            if (highFreqBatchEntries.size() >= 50) {
+            if (highFreqBatchEntries.size() >= 4) {
                 // 批量写入数据库
             }
         } else if (entry.level == LogLevel::ODOMETRY) {
             // 保持原有100条批量写入逻辑不变
         } else {
             writeToFile(entry.message, entry.level, entry.timestamp, entry.source);
 
             StorageLogEntry storageEntry(...);
-            batchEntries.append(storageEntry);
-
-            if (batchEntries.size() >= 100) {
-                // 批量写入数据库
-            }
+            m_pendingBatchEntries.append(storageEntry);
         }
     }
 
-    // 删除 batchEntries 的剩余处理逻辑
-
     // highFreqBatchEntries 和 odometryBatchEntries 的剩余处理保持不变
 
+    // 定时写入逻辑
+    QDateTime now = QDateTime::currentDateTime();
+    if (!m_lastBatchWriteTime.isValid()) {
+        m_lastBatchWriteTime = now;
+    }
+
+    if (!m_pendingBatchEntries.isEmpty() && m_storageEngine && m_storageEngine->isInitialized()) {
+        qint64 elapsedMs = m_lastBatchWriteTime.msecsTo(now);
+        if (elapsedMs >= BATCH_WRITE_INTERVAL_MS) {
+            if (!m_storageEngine->insertLogs(m_pendingBatchEntries)) {
+                qWarning() << "[LogThread] Failed to insert logs to database, will retry next cycle";
+            } else {
+                m_pendingBatchEntries.clear();
+            }
+            m_lastBatchWriteTime = now;
+        }
+    }
 }
```

## 解决方案摘要
- **问题分析**：原有实现中，普通日志每100条批量写入数据库，可能导致日志延迟；HIGHFREQ日志50条阈值过大
- **解决思路**：
  1. 普通日志改为定时写入（2秒间隔），使用成员变量缓存待写入日志
  2. HIGHFREQ日志批量阈值改为4条
  3. ODOMETRY日志保持原有100条批量写入逻辑不变
  4. cleanup时确保缓存日志写入数据库
- **关键修改**：
  - 新增 `m_pendingBatchEntries` 缓存普通日志
  - 新增 `m_lastBatchWriteTime` 记录上次写入时间
  - 新增 `BATCH_WRITE_INTERVAL_MS = 2000` 定义写入间隔
  - `processLogQueue()` 中实现定时检查和写入逻辑

## 行为变化对比

| 日志级别 | 原逻辑 | 新逻辑 |
|---------|--------|--------|
| ODOMETRY | 100条批量写入 | **不变** |
| HIGHFREQ | 50条批量写入 | **4条批量写入** |
| 其他级别 | 100条批量写入 | **定时2秒写入** |

---
记录时间: 2026-02-13

---

# 修改记录（追加）

## 问题描述
1. 历史日志查询只查询 `logs` 表，无法查询高频日志（`high_freq_logs` 表）
2. 日志级别过滤使用"最小级别"逻辑，导致只勾选高频日志时仍能查询到其他级别日志
3. `addLogEntry()` 函数只将日志添加到 UI 显示，未写入数据库，导致大部分日志丢失

## 修改文件列表
- `renwu/logquerytask.h`: 添加 `selectedLevels`、`includeHighFreq`、`includeOdometry` 参数
- `renwu/logquerytask.cpp`: 重构查询逻辑支持多表查询和精确级别匹配
- `renwu/mainwindow.h`: 将 `m_lastQueryMinLevel` 改为 `m_lastQuerySelectedLevels`
- `renwu/mainwindow.cpp`: 修改查询调用、导出功能、`addLogEntry()` 函数

## 修改详情

### renwu/logquerytask.h
**修改位置**: 行12-43

```diff
 struct LogQueryParams {
     QString dbPath;
     QDateTime startTime;
     QDateTime endTime;
-    LogLevel minLevel;
+    QVector<int> selectedLevels;
     QString source;
     QString keyword;
     int limit;
     int offset;
+    bool includeHighFreq;
+    bool includeOdometry;
 
-    LogQueryParams() : limit(-1), offset(0) {}
+    LogQueryParams() : limit(-1), offset(0), includeHighFreq(false), includeOdometry(false) {}
 };
 
 struct LogQueryResult {
     QVector<StorageLogEntry> results;
     QString errorMessage;
     bool success;
+    int totalCount;
 
-    LogQueryResult() : success(false) {}
+    LogQueryResult() : success(false), totalCount(0) {}
 };
 
 class LogQueryTask
 {
 public:
     static LogQueryResult execute(const LogQueryParams& params);
+
+private:
+    static QVector<QVariant> buildWhereClause(const LogQueryParams& params, QString& sql);
+    static void executeQuery(QSqlDatabase& db, const QString& sql, const QVector<QVariant>& bindValues, QVector<StorageLogEntry>& results);
 };
```

### renwu/logquerytask.cpp
**修改位置**: 整个文件重写

```cpp
LogQueryResult LogQueryTask::execute(const LogQueryParams& params)
{
    // ...
    QVector<StorageLogEntry> allResults;

    // 查询 logs 表
    QString sql = "SELECT ... FROM logs WHERE 1=1";
    QVector<QVariant> bindValues = buildWhereClause(params, sql);
    executeQuery(db, sql, bindValues, allResults);

    // 查询 high_freq_logs 表
    if (params.includeHighFreq) {
        QString hfSql = "SELECT ... FROM high_freq_logs WHERE 1=1";
        QVector<QVariant> hfBindValues = buildWhereClause(params, hfSql);
        executeQuery(db, hfSql, hfBindValues, allResults);
    }

    // 查询 odometry_logs 表
    if (params.includeOdometry) {
        // ...
    }

    // 合并结果并按时间排序
    std::sort(allResults.begin(), allResults.end(), ...);
    // ...
}

QVector<QVariant> LogQueryTask::buildWhereClause(const LogQueryParams& params, QString& sql)
{
    // ...
-    if (params.minLevel != LogLevel::DEBUG) {
-        sql += " AND level >= ?";
-        bindValues.append(static_cast<int>(params.minLevel));
+    if (!params.selectedLevels.isEmpty()) {
+        sql += " AND level IN (";
+        for (int i = 0; i < params.selectedLevels.size(); ++i) {
+            if (i > 0) sql += ",";
+            sql += "?";
+            bindValues.append(params.selectedLevels[i]);
+        }
+        sql += ")";
    }
    // ...
}
```

### renwu/mainwindow.h
**修改位置**: 行177-183

```diff
     QDateTime m_lastQueryStartTime;
     QDateTime m_lastQueryEndTime;
-    LogLevel m_lastQueryMinLevel;
+    QSet<int> m_lastQuerySelectedLevels;
     QString m_lastQuerySource;
     QString m_lastQueryKeyword;
+    bool m_lastQueryIncludeHighFreq;
     bool m_hasValidQuery = false;
```

### renwu/mainwindow.cpp
**修改位置1**: 行1-4 (添加头文件)

```diff
 #include "coordinatetransformer.h"
 #include "logutils.h"
+#include "logquerytask.h"
 #include <QPointF>
```

**修改位置2**: 行287-294 (移除重复信号连接)

```diff
     connect(m_systemMonitorThread.get(), &SystemMonitorThread::connectionStateChanged,
             this, &MainWindow::onConnectionStateChanged);
 
-    // SystemMonitorThread日志转发给LogThread统一存储
-    connect(m_systemMonitorThread.get(), &SystemMonitorThread::logMessageReceived,
-            m_logThread.get(), [this](const QString& message, int level, const QDateTime& timestamp) {
-        LogEntry entry(message, static_cast<LogLevel>(level), timestamp, "SystemMonitor");
-        m_logThread->writeLogEntry(entry);
-    });
-
     // RobotStatusThread的诊断信息转发给SystemMonitorThread
```

**修改位置3**: 行1739-1745 (addLogEntry函数添加数据库写入)

```diff
     if (entry.level == LogLevel::ODOMETRY) {
         return;
     }
 
+    // 写入日志线程（存储到文件和数据库）
+    if (m_logThread) {
+        m_logThread->writeLogEntry(entry);
+    }
+
     // 高频日志：独立存储，也进入 UI 显示
```

**修改位置4**: 行1801-1830 (查询参数传递)

```diff
-    LogLevel minLevel = getMinLogLevel(levels);
+    // 移除 minLevel 计算
     // ...
-    m_lastQueryMinLevel = minLevel;
+    m_lastQuerySelectedLevels = levels;
     // ...
     LogQueryParams params;
     // ...
-    params.minLevel = minLevel;
+    params.selectedLevels = levels.values().toVector();
+    params.includeHighFreq = includeHighFreq;
```

**修改位置5**: 行2064-2120 (导出功能改用LogQueryTask)

```diff
 bool MainWindow::exportHistoryLogs(const QString& filePath, bool isCsv)
 {
     // ...
+    LogQueryParams params;
+    params.dbPath = m_logStorage->getDbPath();
+    params.startTime = m_lastQueryStartTime;
+    params.endTime = m_lastQueryEndTime;
+    params.selectedLevels = m_lastQuerySelectedLevels.values().toVector();
+    params.source = m_lastQuerySource;
+    params.keyword = m_lastQueryKeyword;
+    params.includeHighFreq = m_lastQueryIncludeHighFreq;
 
-        QVector<StorageLogEntry> entries = m_logStorage->queryLogs(
-            m_lastQueryStartTime, m_lastQueryEndTime, m_lastQueryMinLevel,
-            m_lastQuerySource, m_lastQueryKeyword, pageSize, offset);
+        params.limit = pageSize;
+        params.offset = offset;
+        LogQueryResult result = LogQueryTask::execute(params);
 
-        for (const auto& entry : entries) {
+        for (const auto& entry : result.results) {
```

## 解决方案摘要

### 问题1：历史日志无法查询高频日志
- **问题分析**：`LogQueryTask::execute` 只查询 `logs` 表，高频日志存储在 `high_freq_logs` 表
- **解决思路**：添加 `includeHighFreq` 和 `includeOdometry` 参数，根据参数决定是否查询对应表
- **关键修改**：重构查询逻辑，支持多表查询，合并结果后按时间排序

### 问题2：日志级别过滤不准确
- **问题分析**：使用 `level >= minLevel` 过滤，导致只勾选高频日志时仍能查到其他级别
- **解决思路**：改为精确匹配，使用 `level IN (selectedLevels)` 过滤
- **关键修改**：`LogQueryParams.minLevel` → `LogQueryParams.selectedLevels`

### 问题3：日志未写入数据库
- **问题分析**：`addLogEntry()` 只更新 UI，未调用 `m_logThread->writeLogEntry()`
- **解决思路**：在 `addLogEntry()` 中统一调用 `m_logThread->writeLogEntry()`
- **关键修改**：移除重复的信号连接，在 `addLogEntry()` 中统一处理日志写入

---
更新时间: 2026-02-13
