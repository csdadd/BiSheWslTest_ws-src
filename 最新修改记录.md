# 修改记录

## 问题描述

`logs.db` 数据库缺少自动清理机制，会随时间无限增长，导致：
- 长期运行后数据库文件过大
- 占用磁盘空间
- 查询性能可能下降

**位置**: `logstorageengine.h/cpp`

**现状分析**:
- 三个表: `logs`, `high_freq_logs`, `odometry_logs`
- 现有清理方法: `clearLogs()`, `clearHighFreqLogs()`, `vacuum()`
- 缺失: `clearOdometryLogs()` 方法和任何自动触发机制
- 内存缓存有限制，但数据库无限制

## 修改文件列表

- `renwu/logstorageengine.h`: 添加 RetentionPolicy 结构体、清理方法声明、成员变量
- `renwu/logstorageengine.cpp`: 实现自动清理逻辑
- `renwu/mainwindow.cpp`: 启动时调用自动清理

## 修改详情

### renwu/logstorageengine.h

**修改1**: 添加 include（第11-13行）

```diff
 #include <QSqlDatabase>
 #include <QSqlError>
+#include <QTimer>
+#include <QFileInfo>
```

**修改2**: 添加 RetentionPolicy 结构体（第36-45行）

```cpp
// 日志保留策略配置
struct RetentionPolicy {
    int retentionDays = 30;         // 普通日志保留天数
    int highFreqRetentionDays = 10; // 高频日志保留天数
    int odometryRetentionDays = 3;  // 里程计保留天数
    qint64 maxDbSizeMB = 500;       // 数据库最大大小（MB）
    int cleanupIntervalHours = 24;  // 定时清理间隔（小时）

    RetentionPolicy() = default;
};
```

**修改3**: 添加公开方法声明（第93-103行）

```cpp
    // 里程计日志相关方法
    bool insertOdometryLogs(const QVector<StorageLogEntry>& entries);
+   bool clearOdometryLogs(const QDateTime& beforeTime = QDateTime());

+   // 自动清理相关方法
+   void setRetentionPolicy(const RetentionPolicy& policy);
+   RetentionPolicy retentionPolicy() const;
+   void startAutoCleanup();
+   void stopAutoCleanup();
+   bool performCleanup();
+   qint64 getDatabaseSize() const;
+   double getDatabaseSizeMB() const;
```

**修改4**: 添加信号（第109行）

```diff
     void errorOccurred(const QString& error);
+    void cleanupCompleted(int logsRemoved, int highFreqRemoved, int odometryRemoved, qint64 bytesFreed);
```

**修改5**: 添加私有成员和方法（第122-131行）

```cpp
    static constexpr int BATCH_INSERT_SIZE = 100;

+   // 自动清理相关成员
+   RetentionPolicy m_retentionPolicy;
+   QTimer* m_cleanupTimer = nullptr;
+
+   // 内部清理辅助方法
+   bool cleanupByRetentionPolicy();
+   bool cleanupBySizeLimit();
 };
```

### renwu/logstorageengine.cpp

**修改1**: 修改析构函数，添加 stopAutoCleanup()（第17-27行）

```diff
 LogStorageEngine::~LogStorageEngine()
 {
+    stopAutoCleanup();
+
     if (m_database.isOpen()) {
         m_database.close();
     }
```

**修改2**: 在文件末尾添加清理方法实现

```cpp
// ============== 里程计日志清理 ==============

bool LogStorageEngine::clearOdometryLogs(const QDateTime& beforeTime)
{
    QWriteLocker locker(&m_lock);

    if (!m_initialized || !m_database.isOpen()) {
        m_lastError = "Database not initialized";
        return false;
    }

    QSqlQuery query(m_database);

    if (beforeTime.isValid()) {
        query.prepare("DELETE FROM odometry_logs WHERE timestamp < ?");
        query.addBindValue(beforeTime.toMSecsSinceEpoch());
    } else {
        query.prepare("DELETE FROM odometry_logs");
    }

    if (!query.exec()) {
        m_lastError = QString("Failed to clear odometry logs: %1").arg(query.lastError().text());
        emit errorOccurred(m_lastError);
        return false;
    }

    qDebug() << "[LogStorageEngine] Cleared odometry logs, affected rows:" << query.numRowsAffected();
    return true;
}

// ============== 保留策略管理 ==============

void LogStorageEngine::setRetentionPolicy(const RetentionPolicy& policy)
{
    m_retentionPolicy = policy;

    // 如果定时器已启动，更新间隔
    if (m_cleanupTimer && m_cleanupTimer->isActive()) {
        m_cleanupTimer->setInterval(m_retentionPolicy.cleanupIntervalHours * 3600 * 1000);
    }
}

RetentionPolicy LogStorageEngine::retentionPolicy() const
{
    return m_retentionPolicy;
}

// ============== 自动清理控制 ==============

void LogStorageEngine::startAutoCleanup()
{
    // 创建定时器（如果不存在）
    if (!m_cleanupTimer) {
        m_cleanupTimer = new QTimer(this);
        connect(m_cleanupTimer, &QTimer::timeout, this, [this]() {
            qDebug() << "[LogStorageEngine] Scheduled cleanup triggered";
            performCleanup();
        });
    }

    // 启动时立即执行一次清理
    qDebug() << "[LogStorageEngine] Performing startup cleanup...";
    performCleanup();

    // 启动定时清理（间隔单位：小时 -> 毫秒）
    int intervalMs = m_retentionPolicy.cleanupIntervalHours * 3600 * 1000;
    m_cleanupTimer->start(intervalMs);

    qDebug() << "[LogStorageEngine] Auto cleanup started, interval:"
             << m_retentionPolicy.cleanupIntervalHours << "hours";
}

void LogStorageEngine::stopAutoCleanup()
{
    if (m_cleanupTimer) {
        m_cleanupTimer->stop();
        delete m_cleanupTimer;
        m_cleanupTimer = nullptr;
        qDebug() << "[LogStorageEngine] Auto cleanup stopped";
    }
}

// ============== 核心清理逻辑 ==============

bool LogStorageEngine::performCleanup()
{
    if (!m_initialized || !m_database.isOpen()) {
        m_lastError = "Database not initialized";
        emit errorOccurred(m_lastError);
        return false;
    }

    qint64 sizeBefore = getDatabaseSize();

    // 1. 按保留时间清理
    if (!cleanupByRetentionPolicy()) {
        return false;
    }

    // 2. 检查数据库大小，必要时按大小清理
    if (getDatabaseSizeMB() > m_retentionPolicy.maxDbSizeMB) {
        if (!cleanupBySizeLimit()) {
            return false;
        }
    }

    // 3. 执行 vacuum 压缩数据库
    vacuum();

    qint64 sizeAfter = getDatabaseSize();
    qint64 bytesFreed = sizeBefore - sizeAfter;

    qDebug() << "[LogStorageEngine] Cleanup completed, freed:" << bytesFreed << "bytes";
    emit cleanupCompleted(0, 0, 0, bytesFreed);

    return true;
}

bool LogStorageEngine::cleanupByRetentionPolicy()
{
    QDateTime now = QDateTime::currentDateTime();

    // 清理普通日志（保留 retentionDays 天）
    QDateTime logsCutoff = now.addDays(-m_retentionPolicy.retentionDays);
    if (!clearLogs(logsCutoff)) {
        qWarning() << "[LogStorageEngine] Failed to clear logs by retention policy";
    }

    // 清理高频日志（保留 highFreqRetentionDays 天）
    QDateTime highFreqCutoff = now.addDays(-m_retentionPolicy.highFreqRetentionDays);
    if (!clearHighFreqLogs(highFreqCutoff)) {
        qWarning() << "[LogStorageEngine] Failed to clear high freq logs by retention policy";
    }

    // 清理里程计日志（保留 odometryRetentionDays 天）
    QDateTime odometryCutoff = now.addDays(-m_retentionPolicy.odometryRetentionDays);
    if (!clearOdometryLogs(odometryCutoff)) {
        qWarning() << "[LogStorageEngine] Failed to clear odometry logs by retention policy";
    }

    return true;
}

bool LogStorageEngine::cleanupBySizeLimit()
{
    QWriteLocker locker(&m_lock);

    if (!m_initialized || !m_database.isOpen()) {
        m_lastError = "Database not initialized";
        return false;
    }

    // 目标大小为最大限制的 80%，留出缓冲空间
    qint64 targetSizeBytes = static_cast<qint64>(m_retentionPolicy.maxDbSizeMB * 0.8 * 1024 * 1024);

    QSqlQuery query(m_database);

    // 辅助 lambda：删除指定表最旧的一半数据
    auto deleteOldestHalf = [&](const QString &table) {
        QString sql = QString("DELETE FROM %1 WHERE id IN "
                              "(SELECT id FROM %1 ORDER BY timestamp ASC LIMIT "
                              "(SELECT COUNT(*)/2 FROM %1))").arg(table);
        return query.exec(sql);
    };

    // 优先删除里程计（占用大、价值低），然后高频日志，最后普通日志
    deleteOldestHalf("odometry_logs");
    if (getDatabaseSize() <= targetSizeBytes) {
        return true;
    }

    deleteOldestHalf("high_freq_logs");
    if (getDatabaseSize() <= targetSizeBytes) {
        return true;
    }

    deleteOldestHalf("logs");
    return true;
}

// ============== 数据库大小查询 ==============

qint64 LogStorageEngine::getDatabaseSize() const
{
    if (m_dbPath.isEmpty()) {
        return 0;
    }

    QFileInfo fileInfo(m_dbPath);
    return fileInfo.size();
}

double LogStorageEngine::getDatabaseSizeMB() const
{
    return static_cast<double>(getDatabaseSize()) / (1024.0 * 1024.0);
}
```

### renwu/mainwindow.cpp

**修改位置**: 第230-238行

```diff
     // 创建统一的日志存储引擎
     m_logStorage = std::make_unique<LogStorageEngine>();
     QString dbPath = QCoreApplication::applicationDirPath() + "/logs/unified_logs.db";
     if (!m_logStorage->initialize(dbPath)) {
         qWarning() << "[MainWindow] Failed to initialize LogStorageEngine:" << m_logStorage->getLastError();
+    } else {
+        // 启动自动清理
+        m_logStorage->startAutoCleanup();
     }
```

## 解决方案摘要

- **问题分析**: 数据库缺少自动清理机制，三张表（logs、high_freq_logs、odometry_logs）均无限增长
- **解决思路**: 实现双重清理策略（按时间 + 按大小），启动时清理 + 定时清理
- **关键修改**:
  1. 添加 `RetentionPolicy` 结构体配置保留策略
  2. 补充 `clearOdometryLogs()` 方法
  3. 实现 `startAutoCleanup()` 启动时清理 + 定时清理
  4. 实现 `cleanupByRetentionPolicy()` 按时间清理
  5. 实现 `cleanupBySizeLimit()` 按大小清理
- **验证方法**: 编译通过 `colcon build --packages-select renwu`

**保留策略配置**:

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `retentionDays` | 30 | 普通日志保留天数 |
| `highFreqRetentionDays` | 10 | 高频日志保留天数 |
| `odometryRetentionDays` | 3 | 里程计保留天数 |
| `maxDbSizeMB` | 500 | 数据库最大大小（MB） |
| `cleanupIntervalHours` | 24 | 定时清理间隔（小时） |

---
记录时间: 2026-02-13
