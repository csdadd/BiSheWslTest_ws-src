# 修改记录

## 问题描述
为 `/home/w/wheeltec_ros2/src/renwu` 添加一个新的日志级别：里程计(ODOMETRY)，将当前属于高频级别的里程计日志改为新建的里程计级别。后续需求变更：里程计日志不显示在UI中，使用独立的数据库表存储，为后续其他用途做准备。

## 修改文件列表
- `renwu/loglevel.h`: 添加 ODOMETRY 日志级别枚举
- `renwu/logutils.h`: 添加 ODOMETRY 字符串转换支持
- `renwu/mainwindow.h`: 移除 m_odometryLogs 缓存，更新注释
- `renwu/mainwindow.cpp`: 移除 ODOMETRY UI显示相关代码，里程计日志直接返回不显示
- `renwu/mainwindow.ui`: 删除 ODOMETRY 相关复选框
- `renwu/logtablemodel.cpp`: 删除 ODOMETRY 颜色定义
- `renwu/logstorageengine.h`: 添加 insertOdometryLogs() 方法声明
- `renwu/logstorageengine.cpp`: 创建 odometry_logs 表，实现插入方法
- `renwu/logthread.h`: 添加 m_odometryLogCount 计数器
- `renwu/logthread.cpp`: ODOMETRY 日志使用独立容器和存储逻辑

## 修改详情

### renwu/loglevel.h
**修改位置**: 行 10-26

```diff
 enum class LogLevel : int {
     DEBUG = 0,
     INFO = 1,
     WARNING = 2,
     ERROR = 3,
     FATAL = 4,
-    HIGHFREQ = 5  // 高频日志级别
+    HIGHFREQ = 5,  // 高频日志级别
+    ODOMETRY = 6   // 里程计日志级别
 };
 
 inline constexpr LogLevel LOG_HIGHFREQ = LogLevel::HIGHFREQ;
+inline constexpr LogLevel LOG_ODOMETRY = LogLevel::ODOMETRY;
```

### renwu/logutils.h
**修改位置**: 行 22-55

```diff
 inline QString levelToString(LogLevel level) {
     switch (level) {
         // ... 其他 case
         case LogLevel::HIGHFREQ:
             return "HIGHFREQ";
+        case LogLevel::ODOMETRY:
+            return "ODOMETRY";
         default:
             return "UNKNOWN";
     }
 }
 
 inline LogLevel levelFromString(const QString& levelStr) {
     // ... 其他 if
     if (upper == "HIGHFREQ") return LogLevel::HIGHFREQ;
+    if (upper == "ODOMETRY") return LogLevel::ODOMETRY;
     return LogLevel::INFO;
 }
```

### renwu/mainwindow.h
**修改位置**: 行 184-200

```diff
-    // 注意：不包含高频日志(HIGHFREQ)和里程计日志(ODOMETRY)，它们有独立缓存
+    // 注意：不包含高频日志(HIGHFREQ)，高频日志有独立缓存 m_highFreqLogs
+    // 里程计日志(ODOMETRY)不显示在 UI 中，直接存储到独立数据库表
     QList<LogEntry> m_allLogs;
     static constexpr int MAX_ALL_LOGS_SIZE = 10000;
 
     QList<LogEntry> m_highFreqLogs;
     static constexpr int MAX_HIGHFREQ_LOGS_SIZE = 1000;
 
-    QList<LogEntry> m_odometryLogs;
-    static constexpr int MAX_ODOMETRY_LOGS_SIZE = 1000;
-
     bool m_logPaused = false;
```

### renwu/mainwindow.cpp
**修改位置**: 行 335-340 (信号连接)

```diff
     connect(ui->highFreqCheckBox, &QCheckBox::stateChanged, this, &MainWindow::onFilterChanged);
-    connect(ui->odometryCheckBox, &QCheckBox::stateChanged, this, &MainWindow::onFilterChanged);
```

**修改位置**: 行 785-803 (refreshLogDisplay)

```diff
     if (ui->highFreqCheckBox->isChecked()) enabledLevels << static_cast<int>(LogLevel::HIGHFREQ);
-    if (ui->odometryCheckBox->isChecked()) enabledLevels << static_cast<int>(LogLevel::ODOMETRY);
```

**修改位置**: 行 805-855 (onClearLogByLevel)

```diff
     if (ui->highFreqCheckBox->isChecked()) levelsToClear << static_cast<int>(LogLevel::HIGHFREQ);
-    if (ui->odometryCheckBox->isChecked()) levelsToClear << static_cast<int>(LogLevel::ODOMETRY);
     
     // 清除高频日志缓存
     if (levelsToClear.contains(static_cast<int>(LogLevel::HIGHFREQ))) {
         clearedCount += m_highFreqLogs.size();
         m_highFreqLogs.clear();
     }
-
-    // 清除里程计日志缓存
-    if (levelsToClear.contains(static_cast<int>(LogLevel::ODOMETRY))) {
-        clearedCount += m_odometryLogs.size();
-        m_odometryLogs.clear();
-    }
```

**修改位置**: 行 1758-1800 (addLogEntry)

```diff
 void MainWindow::addLogEntry(const LogEntry& entry)
 {
     if (m_logPaused) {
         return;
     }
 
+    // 里程计日志：不显示在 UI 中，直接返回（由 LogThread 负责存储到独立数据库表）
+    if (entry.level == LogLevel::ODOMETRY) {
+        return;
+    }
+
     // 高频日志：独立存储，也进入 UI 显示
     if (entry.level == LogLevel::HIGHFREQ) {
         m_highFreqLogs.append(entry);
         // ...
         return;
     }
-
-    // 里程计日志：独立存储，也进入 UI 显示
-    if (entry.level == LogLevel::ODOMETRY) {
-        m_odometryLogs.append(entry);
-        // ...
-        return;
-    }
 
     // 普通日志处理...
 }
```

**修改位置**: 行 1961-1984 (历史日志查询)

```diff
     if (ui->historyHighFreqCheckBox->isChecked()) levels.insert(static_cast<int>(LogLevel::HIGHFREQ));
-    if (ui->historyOdometryCheckBox->isChecked()) levels.insert(static_cast<int>(LogLevel::ODOMETRY));
     return levels;
     
     if (levels.contains(static_cast<int>(LogLevel::HIGHFREQ))) return LogLevel::HIGHFREQ;
-    if (levels.contains(static_cast<int>(LogLevel::ODOMETRY))) return LogLevel::ODOMETRY;
     return LogLevel::INFO;
```

**修改位置**: 行 2172-2192 (全选/清空)

```diff
     ui->historyHighFreqCheckBox->setChecked(true);
-    ui->historyOdometryCheckBox->setChecked(true);
     
     ui->historyHighFreqCheckBox->setChecked(false);
-    ui->historyOdometryCheckBox->setChecked(false);
```

### renwu/mainwindow.ui
**修改位置**: 实时日志区域和历史日志区域

```diff
- 删除 odometryCheckBox 复选框
- 删除 historyOdometryCheckBox 复选框
- 调整列布局编号
```

### renwu/logtablemodel.cpp
**修改位置**: 行 88-94

```diff
         case LogLevel::HIGHFREQ:
             return QColor(100, 100, 255);
-        case LogLevel::ODOMETRY:
-            return QColor(0, 180, 180);
         default:
             return QColor(0, 0, 0);
```

### renwu/logstorageengine.h
**修改位置**: 行 77-80

```diff
     bool clearHighFreqLogs(const QDateTime& beforeTime = QDateTime());
 
+    // 里程计日志相关方法
+    bool insertOdometryLogs(const QVector<StorageLogEntry>& entries);
+
 signals:
```

### renwu/logstorageengine.cpp
**修改位置**: 行 105-145 (createTables)

```diff
     // high_freq_logs 表创建代码...
 
+    QString createOdometryTableSQL = R"(
+        CREATE TABLE IF NOT EXISTS odometry_logs (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            timestamp INTEGER NOT NULL,
+            level INTEGER NOT NULL,
+            message TEXT NOT NULL,
+            source TEXT,
+            category TEXT,
+            file_path TEXT,
+            line_number INTEGER,
+            created_at INTEGER DEFAULT (strftime('%s', 'now'))
+        )
+    )";
+
+    if (!query.exec(createOdometryTableSQL)) {
+        m_lastError = QString("Failed to create odometry_logs table: %1").arg(query.lastError().text());
+        emit errorOccurred(m_lastError);
+        return false;
+    }
```

**修改位置**: 行 188-208 (createIndexes)

```diff
     // high_freq_logs 索引创建代码...
 
+    // 里程计日志表索引
+    QString createOdomTimestampIndex = "CREATE INDEX IF NOT EXISTS idx_odom_timestamp ON odometry_logs(timestamp)";
+    if (!query.exec(createOdomTimestampIndex)) { ... }
+
+    QString createOdomSourceIndex = "CREATE INDEX IF NOT EXISTS idx_odom_source ON odometry_logs(source)";
+    if (!query.exec(createOdomSourceIndex)) { ... }
```

**修改位置**: 行 711-763 (新增方法)

```cpp
 bool LogStorageEngine::insertOdometryLogs(const QVector<StorageLogEntry>& entries)
 {
     QWriteLocker locker(&m_lock);
 
     if (!m_initialized || !m_database.isOpen()) {
         m_lastError = "Database not initialized";
         return false;
     }
 
     if (entries.isEmpty()) {
         return true;
     }
 
     QSqlQuery query(m_database);
     query.prepare(R"(
         INSERT INTO odometry_logs (timestamp, level, message, source, category, file_path, line_number)
         VALUES (?, ?, ?, ?, '', ?, ?)
     )");
 
     if (!m_database.transaction()) {
         m_lastError = QString("Failed to start transaction: %1").arg(m_database.lastError().text());
         emit errorOccurred(m_lastError);
         return false;
     }
 
     int successCount = 0;
     for (const auto& entry : entries) {
         query.addBindValue(entry.timestamp.toMSecsSinceEpoch());
         query.addBindValue(static_cast<int>(entry.level));
         query.addBindValue(entry.message);
         query.addBindValue(entry.source);
         query.addBindValue(entry.filePath);
         query.addBindValue(entry.lineNumber);
 
         if (query.exec()) {
             successCount++;
         }
     }
 
     if (!m_database.commit()) {
         m_lastError = QString("Failed to commit transaction: %1").arg(m_database.lastError().text());
         emit errorOccurred(m_lastError);
         m_database.rollback();
         return false;
     }
 
     emit logInserted(successCount);
     return true;
 }
```

### renwu/logthread.h
**修改位置**: 行 70-72

```diff
     int m_nav2ActiveLogCount = 0;
+    int m_odometryLogCount = 0;
```

### renwu/logthread.cpp
**修改位置**: 行 103-196 (processLogQueue)

```diff
 void LogThread::processLogQueue()
 {
     QVector<StorageLogEntry> batchEntries;
     QVector<StorageLogEntry> highFreqBatchEntries;
+    QVector<StorageLogEntry> odometryBatchEntries;
     LogEntry entry;
 
     while (m_logQueue.tryDequeue(entry, 0)) {
         if (entry.level == LogLevel::HIGHFREQ) {
             // 高频日志处理...
+        } else if (entry.level == LogLevel::ODOMETRY) {
+            m_odometryLogCount++;
+            if (m_odometryLogCount % 10 != 1) {
+                continue;
+            }
+
+            StorageLogEntry storageEntry(entry.message, entry.level, entry.timestamp, entry.source);
+            odometryBatchEntries.append(storageEntry);
+
+            if (odometryBatchEntries.size() >= 50) {
+                if (m_storageEngine && m_storageEngine->isInitialized()) {
+                    if (!m_storageEngine->insertOdometryLogs(odometryBatchEntries)) {
+                        qWarning() << "[LogThread] Failed to insert odometry logs to database";
+                    }
+                }
+                odometryBatchEntries.clear();
+            }
         } else {
             // 普通日志处理...
         }
     }
 
     // 处理剩余的批量条目...
+    if (!odometryBatchEntries.isEmpty() && m_storageEngine && m_storageEngine->isInitialized()) {
+        if (!m_storageEngine->insertOdometryLogs(odometryBatchEntries)) {
+            qWarning() << "[LogThread] Failed to insert remaining odometry logs to database";
+        }
+    }
 }
```

## 解决方案摘要

### 问题分析
原有设计中里程计日志使用 HIGHFREQ 级别，与其他高频日志混在一起。用户需要将里程计日志完全分离，不显示在 UI 中，存储到独立的数据库表，为后续其他用途预留数据。

### 解决思路
1. **添加新日志级别**: 在 `LogLevel` 枚举中添加 `ODOMETRY = 6`
2. **UI 完全分离**: 移除所有 ODOMETRY 相关的 UI 控件和显示逻辑
3. **独立数据库表**: 创建 `odometry_logs` 表，与普通日志和高频日志完全隔离
4. **独立存储流程**: 在 `LogThread` 中使用独立的容器和存储方法处理里程计日志

### 关键修改
- `loglevel.h`: 添加 ODOMETRY 枚举值
- `mainwindow.cpp`: `addLogEntry()` 中 ODOMETRY 日志直接返回，不进入 UI
- `logstorageengine.cpp`: 创建独立的 `odometry_logs` 表和 `insertOdometryLogs()` 方法
- `logthread.cpp`: ODOMETRY 日志使用独立容器，采样后写入独立表

### 验证方法
- 编译通过：`colcon build --packages-select renwu` 成功
- 里程计日志不再显示在 UI 中
- 里程计日志存储在独立的 `odometry_logs` 数据库表中
- 采样策略：每 10 条保留 1 条

---
记录时间: 2026-02-13
